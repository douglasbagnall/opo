#!/usr/bin/python
import pygtk
pygtk.require('2.0')
import gtk, gobject
import subprocess
import os, sys

from ConfigParser import SafeConfigParser, Error as CPError

OPO = './opo'
SCREENS = 4
SCREEN_WIDTH = 1024
SCREEN_HEIGHT = 768
TIMEOUT = 20
CHOOSE_DIR = '.'
UNSTITCHED_DIR = '.'
ENCODER = 'vp8'

RC_FILE = 'opo.rc'
AUTO_MODE = False

class OpoError(Exception):
    pass

def log(*messages):
    for m in messages:
        print >> sys.stderr, m

def name_suggester(dir, base, suffix):
    from os.path import join, exists
    for i in range(1, 999):
        name = "%s-%s.%s" % (base, i, suffix)
        fullname = join(dir, name)
        if not exists(fullname):
            break
    return fullname

def start_stitching_process(output_file, input_files, width, height):
    try:
        for i, fn in enumerate(input_files):
            if not fn.startswith('file://'):
                import urllib
                fn = 'file://' + urllib.quote(os.path.abspath(fn))
                input_files[i] = fn
            #throw exception if unreadable (so no http uris)
            open(fn[6:]).close()
    except AttributeError, e: #"None has no attribute startswith"
        log(e)
        raise OpoError("Not all input files are specified")
    except IOError, e:
        raise OpoError(e)

    encoders = {
        'vp8': ['vp8enc', 'quality=7'],
        'mjpeg': ['jpegenc', 'idct-method=2'],
        }

    pipeline = (['gst-launch-0.10',
                 'videomixer',
                 'name=mix',
                 'background=1',
                 '!', 'ffmpegcolorspace',
                 '!',
                ]
                + encoders[ENCODER]
                + [
                '!', 'avimux',
                '!', 'filesink', 'location=%s' % output_file,
                ])
    for i, fn in enumerate(input_files):
        left = i * width
        right = (len(input_files) - 1 - i) * width
        pipeline.extend([
            'uridecodebin',
            'uri=%s' % fn,
            '!', 'deinterlace',
            '!', 'videoscale',
            '!', 'video/x-raw-yuv,', 'width=%s,' % width, 'height=%s' % height,
            ';', 'video/x-raw-rgb,', 'width=%s,' % width, 'height=%s' % height,
            '!', 'videobox', 'border-alpha=0', 'alpha=1', 'left=-%s' % left, 'right=-%s' % right,
            '!', 'mix.',
            ])

    log(' '.join(pipeline))
    p = subprocess.Popen(pipeline)
    return p

class Launcher:
    is_auto = None
    auto_tick_id = None
    stitch_tick_id = None
    tiemout = TIMEOUT
    chooser = None

    def play(self):
        """Play the currently selected video"""
        cmd = [OPO, '-s', str(self.screens), '-c', self.video, '-w', '256', '-h', '192']
        log("Starting play:", cmd)
        subprocess.call(cmd)

    def on_play_now(self, widget, data=None):
        self.play()

    def on_mode_switch(self, widget, data=None):
        """Turning auto mode on or off, according to the widget's
        state ('active' is auto).  If the widget is toggled to the
        current mode, ignore it."""
        auto = widget.get_active()
        if auto == self.is_auto:
            log("spurious auto toggle")
            return
        self.is_auto = auto
        for x in self.advanced_widgets:
            x.set_sensitive(not auto)
        if auto:
            self.start_auto_countdown()
        else:
            self.stop_auto_countdown()

    def start_auto_countdown(self):
        self.countdown = self.timeout
        if self.auto_tick_id is None: #lest, somehow, two ticks try going at once.
            self.auto_tick_id = gobject.timeout_add(1000, self.auto_tick)

    def stop_auto_countdown(self):
        if self.auto_tick_id is not None:
            gobject.source_remove(self.auto_tick_id)
            self.auto_tick_id = None
        self.mode_switch.set_label("Play _automatically in %s seconds" % self.timeout)

    def auto_tick(self):
        self.countdown -= 1
        if self.countdown > 0:
            if self.countdown == 1:
                self.mode_switch.set_label("Play _automatically in one second!")
            else:
                self.mode_switch.set_label("Play _automatically in %s seconds" % self.countdown)
            return True
        self.auto_tick_id = None
        self.play()
        #returning False stops countdown, which is perhaps irrelevant
        #as self.play should never return
        return False

    def choose_file(self, widget, *data):
        self.video = widget.get_uri()
        self.update_heading()
        self.update_choose_dir(widget.get_current_folder())

    def stitch_video(self, widget, data=None):
        """Launch the video joining gstreamer process, show a progress
        bar/ spinner, and start a ticker that watches for its end."""
        log("stitching video !")
        output_file = self.stitch_target_field.get_text()
        input_files = [x.get_uri() for x in self.screen_choosers]
        width = int(self.width_field.get_text())
        height = int(self.width_field.get_text())
        self.stitching_process = start_stitching_process(output_file, input_files, width, height)
        #self.stitching_process = subprocess.Popen(['sleep', '10'])
        self.progress_bar = gtk.ProgressBar()
        self.progress_bar.set_pulse_step(0.02)
        self.vbox.pack_start(self.progress_bar)
        self.stitch_button.hide()
        self.progress_bar.show()
        self.stitch_tick_id = gobject.timeout_add(150, self.stitch_tick)

    def stitch_tick(self):
        """Spin the progress bar and wait for the finished video"""
        r = self.stitching_process.poll()
        if r is None:
            self.progress_bar.pulse()
            return True
        if r != 0:
            #XXX should catch and display gstreamer output
            log("got result %s" % r)
        self.progress_bar.hide()
        self.stitch_button.show()
        self.stitch_tick_id = None
        #XXX make the new video the chosen one
        return False

    def on_choose_stitch_target(self, widget, data=None):
        dialog = gtk.FileChooserDialog("Save as", action=gtk.FILE_CHOOSER_ACTION_SAVE,
                                       flags=gtk.DIALOG_MODAL,
                                       buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                                        gtk.STOCK_OK, gtk.RESPONSE_ACCEPT)
                                       )
        dialog.set_do_overwrite_confirmation(True)
        if self.choose_dir:
            dialog.set_current_folder(self.choose_dir)

        response = dialog.run()
        filename = dialog.get_filename()
        if response in (gtk.RESPONSE_ACCEPT, gtk.RESPONSE_OK):
            directory, basename = os.path.split(filename)
            self.update_choose_dir(directory)
            self.stitch_target_field.set_text(dialog.get_filename())
        log(response)
        dialog.destroy()


    def read_rc(self):
        rc = SafeConfigParser()
        rc.read(RC_FILE)
        def _get(section, item, default=None):
            try:
                return rc.get(section, item)
            except CPError, e:
                log(e)
                return default

        self.unstitched_dir = _get('Paths', 'unstitched_dir', UNSTITCHED_DIR)
        self.update_choose_dir(_get('Paths', 'choose_dir', CHOOSE_DIR))
        self.video = _get('Paths', 'last_played')
        self.timeout = int(_get('Misc', 'timeout', TIMEOUT))
        self.screens = int(_get('Misc', 'screens', SCREENS))
        self.default_width = int(_get('Misc', 'screen_width', SCREEN_WIDTH))
        self.default_height = int(_get('Misc', 'screen_height', SCREEN_HEIGHT))

    def write_rc(self):
        rc = SafeConfigParser()
        rc.read(RC_FILE)
        for section, key, value in (
            ('Paths', 'unstitched_dir', self.unstitched_dir),
            ('Paths', 'choose_dir', self.choose_dir),
            ('Paths', 'last_played', self.video),
            ):
            if value is not None:
                if not rc.has_section(section):
                    rc.add_section(section)
                rc.set(section, key, value)

        with open(RC_FILE, 'wb') as configfile:
            rc.write(configfile)

    def update_heading(self):
        if self.video is not None:
            video_name = self.video.rsplit('/', 1)[1]
            self.heading.set_markup('<big><b>%s</b> is ready to play</big>' %
                                    video_name)
            self.play_now.set_sensitive(True)
        else:
            self.heading.set_markup('<big>No video selected</big>')
            self.play_now.set_sensitive(False)

    def update_choose_dir(self, choosedir):
        self.choose_dir = choosedir
        if self.chooser:
            self.chooser.set_current_folder(choosedir)

    def make_window(self):
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_border_width(15)
        self.vbox = gtk.VBox(False, 3)
        self.advanced_widgets = []

        _add = self.vbox.pack_start
        def _add_advanced(widget):
            self.vbox.pack_start(widget)
            self.advanced_widgets.append(widget)

        def _sep():
            # add a separator with slightly more space than usual
            _add(gtk.HSeparator(), True, True, 5)

        # heading
        h = gtk.Label()
        h.set_line_wrap(True)
        _add(h)
        self.heading = h

        self.play_now = gtk.Button("_Play now")
        self.play_now.connect("clicked", self.on_play_now, None)
        _add(self.play_now)
        _sep()

        #auto toggle
        self.mode_switch = gtk.CheckButton("Play _automatically in %s seconds" % self.timeout)
        self.mode_switch.connect("toggled", self.on_mode_switch, None)
        _add(self.mode_switch)
        _sep()

        #choose another
        chooser_lab = gtk.Label("Ch_oose another combined video (%s screens)" % self.screens)
        chooser_lab.set_use_underline(True)
        chooser_lab.set_alignment(0, 0.5)
        self.chooser = gtk.FileChooserButton(title="video")
        if self.choose_dir:
            self.chooser.set_current_folder(self.choose_dir)
        self.chooser.set_width_chars(40)
        self.chooser.connect('file-set', self.choose_file, None)

        chooser_lab.set_mnemonic_widget(self.chooser)

        _add_advanced(chooser_lab)
        _add_advanced(self.chooser)
        _sep()

        #create another by stitching subvideos
        nb = gtk.Label("Construct a _new combined video out of %s video files" % self.screens)
        nb.set_use_underline(True)

        nb.set_alignment(0, 0.5)
        _add_advanced(nb)

        self.screen_choosers = []
        for i in range(self.screens):
            fc = gtk.FileChooserButton(title="video %s" % i)
            fcl = gtk.Label("Screen _%s" % (i + 1))
            fcl.set_use_underline(True)
            fcl.set_mnemonic_widget(fc)
            fc_set = gtk.HBox()
            fc_set.pack_start(fcl, False)
            fc_set.pack_start(fc)
            self.screen_choosers.append(fc)
            _add_advanced(fc_set)

        #save_as box
        #XXX file filters
        self.stitch_target_field = gtk.Entry()
        self.stitch_target_field.set_width_chars(40)
        self.stitch_target_field.set_text(name_suggester(self.choose_dir, 'new', 'avi'))

        self.choose_stitch_target = gtk.Button(label="choose")
        self.choose_stitch_target.connect("clicked", self.on_choose_stitch_target, None)

        hb = gtk.HBox()
        name_label = gtk.Label("Save as")
        hb.pack_start(name_label, False)
        hb.pack_start(self.stitch_target_field)
        hb.pack_start(self.choose_stitch_target)
        nb.set_mnemonic_widget(self.screen_choosers[0])
        _add_advanced(hb)

        #width/height boxes
        hb = gtk.HBox()
        label = gtk.Label("Pixel size of each screen: ")
        hb.pack_start(label, False)
        for name, default, label in (
            ('width_field', self.default_width, "_width"),
            ('height_field', self.default_height, "_height"),
            ):
            e = gtk.Entry()
            e.set_width_chars(5)
            e.set_alignment(1)
            e.set_text(str(default))
            setattr(self, name, e)
            lb = gtk.Label(label)
            lb.set_use_underline(True)
            lb.set_mnemonic_widget(e)
            hb.pack_start(lb, False)
            hb.pack_start(e, False)
        _add_advanced(hb)

        #stitch button
        self.stitch_button = gtk.Button("Assemble the new _video")
        self.stitch_button.connect("clicked", self.stitch_video, None)
        _add_advanced(self.stitch_button)

        self.window.add(self.vbox)


    def __init__(self):
        self.read_rc()
        self.make_window()
        self.update_heading()
        self.mode_switch.set_active(AUTO_MODE and self.video is not None)
        self.window.connect("destroy", self.destroy)
        self.window.show_all()


    def destroy(self, widget, data=None):
        log("bye")
        self.write_rc()
        gtk.main_quit()

    quit_onclick = destroy

if __name__ == '__main__':
    start = Launcher()
    gtk.main()
